\documentclass[a4paper]{article}
\usepackage{lipsum}
\usepackage{url}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{enumerate}
\usepackage{multicol}
\usepackage{enumitem}
\lstset{language=Haskell}
\usepackage[margin=2cm]{geometry}
\graphicspath{ {images/} }
\renewcommand{\familydefault}{\sfdefault}

\title{COMP4075/G54RFP Coursework Part III}
\date{16\textsuperscript{th} January 2019}
\author{Benjamin Charlton --- psybc3 --- 4262648}

\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\lhead{Benjamin Charlton | psybc3 | 4262648}
\rhead{G54RFP --- Part III Project}
\cfoot{\thepage}

\begin{document}

% TODO
% Around 5 pages or 1500 words long
%   excluding large code fragments, pictures, and any appendices
% README file in root
%   brief overview of the source code hierarchy
%   making clear what was from scratch - IE all of it

\maketitle

\section{Project Overview}
\subsection{Motivation}
The original basis for this project comes from a series of lab exercises from the G52AIM module, Artificial Intelligence Methods.
The lab exercises involved implementing a variety of AI methods to solve some basic optimisation problems namely MAX-SAT problems.
\par
Many of the methods implemented involved combining smaller functions together to create the desired effect.
This could effectively translated into a functional programming setting.
I thought it would be interesting to try and reimplement these some of these methods in Haskell to see the benefits of the FP paradigm to these AI methods.

\subsection{Technical Background}
\subsubsection{MAX-SAT}
MAX-SAT is an optimisation problem which is NP-Hard.
Given a logic formula in conjunctive normal form, the aim is to maximise the number of clauses which are true after variable assignment.
A logical problem in conjunctive normal form has the following formal grammar.
\begin{lstlisting}
CNF -> (C) | (C) & CNF      L -> V | !V
C   -> L   | L + C          V -> 1 | 2 | 3 | ...
\end{lstlisting}
\paragraph{CNF Formula}\vspace*{-6mm}
A CNF formula is made up of clauses which are logically and'd together.
If each clause in a CNF problem is true then the whole formula will return true.
Although in MAX-SAT we aren't aiming for all clauses to be true only to maximise the number that are true.
\paragraph{Clauses C}\vspace*{-4mm}
Each clause contains a series of literals, which are logically or'd together.
This means so long as any literal can evaluate to true the whole clause will be true.
\paragraph{Literals L}\vspace*{-4mm}
A literal is a variable which is either positive or negative, this is achieved by applying a logical not or not doing so.
\paragraph{Variables V}\vspace*{-4mm}
Finally each literal is assigned a variable which are later used to evaluate a solution.
There can be any number of variables so integers are used here in this example to represent the different variables.
\paragraph{Solution for CNF}
A solution for CNF will involve all of the variables in the problem being given a boolean value.
From here you can evaluate each clause and then find how many clauses evaluate to true.
One benefit of how this problem works is that any solution (granting that all variables required have an assignment) will be a valid solution to the problem.

\subsubsection{Mathematical Optimisation}
The MAX-SAT problem is a form of optimisation problem that can be solved by a optimisation technique.
An optimisation problem means that there is an objective function that you wish to maximise the value of by changing the input.
In the case of MAX-SAT the objective function is the number of clauses that evaluate to true given our solution as input.
The goal of any optimisation problem is to find the solution that gives the best possible value for the objective function.
\par
In MAX-SAT there may be several optimal solutions and it is hard to calculate if you do have an optimal solution.
Apart from the trivial case of all clauses being true there is no guarantee that an optimal solution has been found, there is also no guarantee that all clauses can be true either.
\par
While you could devise a way to generate all possible solutions and evaluate them all to find the optimal, due to the NP-hardness of this problem this method will take none polynomial time to run which is very inefficient.
The field of mathematical optimisation aims to find techniques to more efficiently find optimal or near optimal solutions to these types of problems.
While the techniques used for this project don't guarantee optimal solutions the achieve near optimal solutions that have been shown to produce solutions very close to the true optimum.
Although MAX-SAT doesn't have any immediately obvious applications it is very similar to problems such as scheduling where near optimal solutions may be sufficient so the application of these algorithms have real world importance.

\subsection{Aims of the Project}
The original coursework took place over several lab sessions, incorporating a variety of topics and theoretical questions, as well as originally relying heavily of a java based framework.
Due to this only part of the lab exercises will be looked into and some parts of the java framework will have to be remade in Haskell.
\par
Here is what I intend to create in this project:\vspace*{-4mm}
\begin{multicols}{3}
    \begin{itemize}[noitemsep,nolistsep]
        \item MAX-SAT problem generator
        \item MAX-SAT evaluator
        \item Naive solvers
        \item Hill Climbing solvers
        \item Genetic Algorithm Solver
    \end{itemize}
\end{multicols}
While creating this components, real world functional programming techniques will be applied to make this work efficient and maintainable.

\section{Implementaion}
% Discussion of the implementation, justifying key decisions and highlighting and explaining particularly interesting aspects, illustrating with excerpts from the developed code where appropriate.
In this section the implementation of each component will be discussed including any key decisions and interesting aspects.
\subsection{MAX-SAT problem generator}
In the java framework there was the ability to generate a MAX-SAT problem in a suitable form, before any solvers could exist this component and decisions of how the problem will appear also had to be made.

% While the number of clauses and literals can be infinite we bound them
% While each clause can have a different number of literals we keep them the same




\subsection{MAX-SAT evaluator}
\subsection{Naive solvers}
\subsection{Hill Climbing solvers}
\subsection{Genetic Algorithm Solver}




% Implementaion
The MAX-SAT problems were generated by a framework given in the original courseworks, this was via a java file that could be imported.

\section{Learnt stuff --- Needs another name}
A section reflecting upon what was learned from the project and your
thoughts around the project topic from a real-world programming perspective.

\end{document}
